from __future__ import annotations

import asyncio
import time
from datetime import datetime, timezone
from pathlib import Path

from fastapi import FastAPI
from fastapi.testclient import TestClient

from api.routes_chat import router as chat_router
from chat.memory_store import ChatMemoryStore
from chat.runtime import ChatAgentRuntime
from chat.state_store import ChatStateStore
from infrastructure.run_state_store import RunStateStore


def _utcnow() -> str:
    return datetime.now(timezone.utc).isoformat()


def _wait_until(assertion, timeout_s: float = 4.0) -> None:
    started = time.time()
    while time.time() - started < timeout_s:
        if assertion():
            return
        time.sleep(0.05)
    raise AssertionError("Condition was not met before timeout")


class _FakeOrchestrator:
    def scan_steps(self, project_root: str) -> dict:
        return {
            "project_root": project_root,
            "steps_count": 12,
            "updated_at": _utcnow(),
            "sample_steps": [],
            "unmapped_steps": [],
        }

    def apply_feature(self, project_root: str, target_path: str, feature_text: str, *, overwrite_existing: bool = False) -> dict:
        _ = feature_text
        return {
            "projectRoot": project_root,
            "targetPath": target_path,
            "status": "overwritten" if overwrite_existing else "created",
            "message": None,
        }


class _ImmediateSupervisor:
    def __init__(self, store: RunStateStore) -> None:
        self._store = store

    async def execute_job(self, job_id: str) -> None:
        snapshot = self._store.get_job(job_id)
        if not snapshot:
            return
        self._store.patch_job(job_id, status="running", run_id="run-1")
        await asyncio.sleep(0.02)
        self._store.patch_job(
            job_id,
            status="succeeded",
            finished_at=_utcnow(),
            result={
                "featureText": "Feature: generated by chat",
                "unmappedSteps": [],
                "unmapped": [],
                "usedSteps": [],
                "buildStage": "ok",
                "stepsSummary": {"exact": 1, "fuzzy": 0, "unmatched": 0},
                "meta": {"source": "test"},
                "pipeline": [],
                "fileStatus": None,
            },
        )


def _build_app(tmp_path: Path) -> FastAPI:
    app = FastAPI()
    run_state_store = RunStateStore()
    chat_state_store = ChatStateStore(ChatMemoryStore(tmp_path / "chat_memory"))
    runtime = ChatAgentRuntime(
        orchestrator=_FakeOrchestrator(),
        run_state_store=run_state_store,
        execution_supervisor=_ImmediateSupervisor(run_state_store),
        state_store=chat_state_store,
    )
    app.state.run_state_store = run_state_store
    app.state.chat_state_store = chat_state_store
    app.state.chat_runtime = runtime
    app.include_router(chat_router)
    return app


def test_chat_session_create_and_reuse(tmp_path: Path) -> None:
    app = _build_app(tmp_path)
    client = TestClient(app)

    response = client.post(
        "/chat/sessions",
        json={"projectRoot": str(tmp_path), "source": "test-suite", "profile": "quick"},
    )
    assert response.status_code == 200
    first = response.json()
    assert first["reused"] is False
    session_id = first["sessionId"]

    second_response = client.post(
        "/chat/sessions",
        json={"projectRoot": str(tmp_path), "source": "test-suite", "profile": "quick"},
    )
    assert second_response.status_code == 200
    second = second_response.json()
    assert second["reused"] is True
    assert second["sessionId"] == session_id


def test_scan_steps_command_runs_without_confirmation(tmp_path: Path) -> None:
    app = _build_app(tmp_path)
    client = TestClient(app)
    session = client.post("/chat/sessions", json={"projectRoot": str(tmp_path)}).json()
    session_id = session["sessionId"]

    send = client.post(
        f"/chat/sessions/{session_id}/messages",
        json={"content": "/scan-steps"},
    )
    assert send.status_code == 200

    def _has_assistant_message() -> bool:
        history = client.get(f"/chat/sessions/{session_id}/history").json()
        return any("Сканирование завершено" in msg["content"] for msg in history["messages"] if msg["role"] == "assistant")

    _wait_until(_has_assistant_message)

    history = client.get(f"/chat/sessions/{session_id}/history").json()
    assert history["pendingToolCalls"] == []


def test_generate_feature_job_requires_confirmation_and_runs_after_approval(tmp_path: Path) -> None:
    app = _build_app(tmp_path)
    client = TestClient(app)
    session = client.post("/chat/sessions", json={"projectRoot": str(tmp_path)}).json()
    session_id = session["sessionId"]

    send = client.post(
        f"/chat/sessions/{session_id}/messages",
        json={"content": "/generate-test Given user opens profile"},
    )
    assert send.status_code == 200

    def _has_pending_call() -> bool:
        history = client.get(f"/chat/sessions/{session_id}/history").json()
        return len(history["pendingToolCalls"]) == 1

    _wait_until(_has_pending_call)
    history = client.get(f"/chat/sessions/{session_id}/history").json()
    tool_call_id = history["pendingToolCalls"][0]["toolCallId"]

    decision = client.post(
        f"/chat/sessions/{session_id}/tool-decisions",
        json={"toolCallId": tool_call_id, "decision": "approve"},
    )
    assert decision.status_code == 200

    def _job_completed() -> bool:
        snapshot = client.get(f"/chat/sessions/{session_id}/history").json()
        if snapshot["pendingToolCalls"]:
            return False
        return any("завершен со статусом `succeeded`" in msg["content"] for msg in snapshot["messages"] if msg["role"] == "assistant")

    _wait_until(_job_completed)

